# 최원재 202230137
## 5월 15일(10주차)

# 1교시
## package의 운영 방법
1. 패키지 이름은 도메인 기반으로 시작 (일반 관례)형식 : com.회사이름.프로젝트명.기능명 -> 충돌 방지 (전 세계 어디서든 유일한 패키지명 확보 가능) / 모듈별 분리 가능
2. 기능/역할별로 하위 패키지를 구분 : utils. controller, service 등
3. 디렉토리 구조와 package 선언을 정확히 일치해야 함.
4. import는 필요한 만큼만, * 전체 import는 피하는 것이 좋다.

## 모듈 개념
1. java9에서 도입된 개념
2. 패키지와 이미지 등의 리소스를 담은 컨테이너
3. 모듈 파일(.jmod)로 저장

## 자바 플랫폼의 모듈화
* 자바 플랫폼
1. 자바의 개발 환경과 실행 환경을 지칭
2. 자바API의 모든 클래스가 여러 개의 모듈로 재구성됨
3. 모듈 파일은 JDK의 jmod 디렉터리에 저장하여 배포

* 테스트를 할 때는 temp디렉토리를 만들어서 하는 
것이 좋다.

## 자바 모듈화의 목적
* 자바 컴포넌트들을 필요에 따라 조립하여 사용하기 위함
* 컴퓨터 시스템의 불필요한 부담 감소
1. 세밀한 모듈화를 통해 필요 없는 모듈이 로드되지 않게 함
2. 소형 IoT 장치에도 자바 응용프로그램이 실행되고 성능을 유지하게 함

## JDK의 주요 패키지
* java.lang
1. 스트링, 수학 함수, 입출력 등 자바 프로그래밍에 필요한 기본적인 클래스와 인터페이스
2. 자동으로 import 됨 - import 문 필요 없음
* java.util
1. 날짜, 시간, 벡터, 해시맵 등과 같은 다양한 유틸리티 클래스와 인터페이스 제공
* java.io
1. 키보드, 모니터 등에 입출력을 할 수 있는 클래스와 인터페이스 제공
* java.awt
1. GUI 프로그램을 작성하기 위한 AMT패키지
* javax.swing
1. GUI 프로그램을 작성하기 위한 스윙 패키지

## object 클래스
* 모든 자바 클래스는 반드시 object를 상속받도록 자동 컴파일
* 모든 클래스의 수퍼 클래스
* 모든 클래스가 상속받는 공통 메소드 포함함

## 객체 속성
* object 클래스는 객체의 속성을 나타내는 메소드 제공
* hashCode() 메소드
1. 객체의 해시코드 값을 리턴하며, 객체마다 다름
* getClass() 메소드
1. 객체의 클래스 정보를 담은 Class 객체 리턴
2. class 객체의 getName() 메소드는 객체의 클래스 이름 리턴
* toString() 메소드
1. 객체를 문자열로 리턴

# 2교시

## toString() 메소드, 객체를 문자열로 변환
* 각 클래스는 toString()을 오버라이딩하여 자신만의 문자열 리턴 가능
1. 객체를 문자열로 반환
2. 원형 : public String toString();

* 컴파일러에 의핳ㄴ toString()자동 변환
1. '객체 + 문자열' -> '객체.toStrin() + 문자열'로 자동 변환
2. 객체를 단독으로 사용 하는 경우 -> 객체toString()으로 자동변환

## 객체 비교(==)와 equals() 메소드
* == 연산자 : 객체 레퍼런스 비교
* boolean equals(object obj)
1. 두 객체의 내용물 비교
2. 객체의 내용물을 비교하기 위해 클래스의 멤버로 작성

### 예제61, 62, 63, 64 확인

# 3교시

## Wrapper 클래스
* Wrapper 클래스 : 자바의 기본 타입을 클래스화 한 8개 클래스를 통칭
* 용도 : 객체만 사용할 수 있는 컬렉션 등에 기본 타입의 값을 사용하기 위해 Wrapper 객체로 만들어 사용 

## Wrapper 활용
1. Wrapper 객체로부터 기본 타입 값 알아내기
2. 문자열을 기본 데이터 타입으로 변환
3. 기본 타입을 문자열로 변환

## 박싱과 언박싱
* 박싱 : 기본 타입의 값을 Wrapper 객체로 변환하는 것.
* 언박싱 : Wrapper 객체에 들어 있는 기본 타입의 값을 빼내는 것. 박싱의 반대.
* 자동 박싱과 자동 언박싱 : JDK .15부터 박싱과 언박싱은 자동으로 이루어지도록 컴파일됨

## String의 생성과 특징
* String 클래스는 문자열을 나타냄
* 스트링 리터럴(문자열 리터럴)은 String 객체로 처리됨
* 스트링 객체의 생성 사례 
~~~java
String str1 = "abcd"
char data[] = {'a', 'b', 'c', 'd'};
String str2 = new String(data);
String str3 = new String("abcd"); //str2와 str3은 모두 "abcd"스트링
~~~

## 스트링 리터럴과 new String()
* 스트링 리터럴
1. 자바 가상 기계 내부에서 리터럴 테이블에 저장되고 관리됨
2. 응용프로그램에서 공유됨
3. 스트링 리터럴 사례) String s = "Hello";

* new String()으로 생성된 스트링
1. 스트링 객체는 힙에 생성
2. 스트링은 공유되지 않음

## String 활용
* 스트링 비교, equals()와 comapareTo() -> 스트링 비교에 == 연산자 절대 사용 금지
1. equals() : 스트링이 같으면 true, 아니면 false 리턴
 ~~~java
 String java="Java";
 if(java.equals("Java")) //true
 ~~~

# 최원재 202230137
## 5월 8일(9주차)

# 1교시
### 추상 클래스
* 추상 메소드 : abstract로 선언된 메소드, 메소드의 코드는 없고 원형만 선언
* 추상 클래스 
1. 추상 메소드를 가지며, abstract로 선언된 클래스
2. 추상 메소드 없이, abstract로 선언한 클래스
### 추상 클래스의 인스턴스 생성 불가
* 추상 클래스는 온전한 클래스가 아니기 때문에 인스턴스를 생성할 수 없음
### 추상 클래스의 상속과 구현
* 추상 클래스 상속 
1. 추상 클래스를 상속받으면 추상 클래스가 됨
2. 서브 클래스도 abstract로 선언해야 함
* 추상 클래스 구현
1. 서브 클래스에서 슈퍼 클래스의 추상 메소드 구현 (오버라이딩)
2. 추상 클래스를 구현한 서브 클래스는 추상 클래스가 아님
### 추상 클래스의 목적
* 추상 클래스의 목적
1. 상속을 위한 슈퍼 클래스로 활용하는 것
2. 서브 클래스에서 추상 메소드 구현
3. 다형성 실현

## 예제 추상 클래스 구현
* Calculator를 상속받는  GoodCalc 클래스를 구현
~~~java
abstract class Calcuator {
    public abstract int add(int a, int b);

    public abstract int substract(int a, int b);

    public abstract double average(int[] a);
}
~~~

## 자바의 인터페이스
* 소프트웨어를 규격화된 모듈로 만들고, 인터페이스가 맞는 모듈을 조립하듯이 응용프로그램을 작성 하기위해서 사용
* 자바의 인터페이스
1. 클래스가 구현해야 할 메소드들이 선언되는 추상형
2. 인터페이스 선언 : interface 키워드로 선언
* 자바 인터페이스에 대한 변환
1. java 7까지 : 인터페이스는 상수와 추상 메소드로만 구성
2. java 8부터 : 상수와 추상메소드 포함 default 메소드 포함

## 인터페이스의 구성 요소들의 특징
- [인터페이스의 구성 요소들]
1. 상수 : public만 허용, public static final 생략
2. 추상 메소드 : public abstract 생략 가능
* default 메소드 : 
1. 인터페이스에 코드가 작성된 메소드
2. 인터페이스를 구현하는 클래스에 자동 상속
3. public 접근 지정만 허용. 생략 가능
* private 메소드 :
1. 인터페이스 내에 메소드 코드가 작성되어야 함
2. 인터페이스 내에 있는 다른 메소드에 의해서만 호출가능
* static 메소드 : public, private 모두 지정 가능. 생력하면 public

## 자바 인터페이스 특징
1. 인터페이스의 객체 생성 불가 (new PhoneInterface(); // 오류. 인터페이스 PhoneInterface 객체 생성 불가)
2. 인터페이스 타입의 레퍼런스 변수 선언 가능

## 인터페이스 상속
* 인터페이스 가넹 상속 가능 :
1. 인터페이스를 상속하여 확장된 인터페이스 작성 가능
2. extends 키워드로 상속 선언
3. 인터페이스 다중 상속 허용(* 일반 상속에서는 허용하지 않음)
## 인터페이스 구현
* 인터페이스의 추상 메소드를 모두 구현한 클래스 작성
1. implements 키워드 사용
2. 여러 개의 인터페이스 동시 구현 가능
* 인터페이스 구현 사례
1. PhoneInterface 인터페이스를 구현한 SamsungPhone 클래스

# 2교시시

## 예제 
~~~java
interface PhoneInterface {
    final int TIMEOUT = 10000;

    void sendCall();

    void receiveCall();

    default void printLogo() {
        System.out.println("** Phone");
    }
    
}

class SamsungPhone implements PhoneInterface {
    @Override
    public void sendCall() {
        System.out.println("띠리리링");
    }

    @Override
    public void receiveCall() {
        System.out.println("전화가 왔습니다.");
    }

    public void flash() {
        System.out.println("전화기에 불이 켜졌습니다.");
    }
}

public class Ex56interface {
    public static void main(String[] args) {
        SamsungPhone phone = new SamsungPhone();
        phone.printLogo();
        phone.sendCall();
        phone.receiveCall();
        phone.flash();
    }
}
~~~

### 패키지 개념과 필요성
* 3명이 분담하여 자바 응용프로그램을 개발하는 경우, 동일한 이름의 클래스가 존재할가능성 있음. -> 합칠 때 오류 발생 가능성. -> 개발자가 서로 다른 디렉터리로 코드 관리하여 해결

### 자바의 패키지와 모듈이란? 
* 패키지(package)
1. 서로 관련된 클래스와 인터페이스를 컴파일한 클래스 파일들을 묶어 놓은 디렉터리
2. 하나의 응용프로그램은 한 개 이상의 패키지로 작성
3. 패키지는 jar 파일로 압축할 수 있음

* 모듈(module)
1. 여러 패키지와 이밎 등의 자원을 모아 놓은 컨테이너
2. 하나의 모듈을 하나의 .jmod 파일에 저장

* java 9부터 모듈화 도입
1. 플랫폼의 모듈화 : java 9부터 자바 API의 모든 클래스들(자바 실행 환경)을 패키지 기반에서 모듈들로 완전히 재구성
2. 응용프로그램의 모듈화 : 클래스들은 패키지로 만들고, 다시 패키지를 모듈로 만듦
모듈 프로그래밍은 어렵고 복잡.

## 자바의 모듈화의 목적
* 모듈화의 목적
1. java 9부터 자바 API를 여러 모듈(99개)로 분할 : java 8까지는  rt.jar의 한 파일에 모든 API 저장. # 현재 70개로 정리됨.
2. 응용프로그램이 실행할 때 꼭 필요한 모듈들로만 실행 환경 구축 : 메모리 자원이 열약한 작은 소형 기기에 꼭 필요한 모듈로 구성된 작은 크기의 실행 이미지를 만들기 위함
* 모듈의 현실 
1. java 9부터 전면 도입
2. 복잡한 개념
3. 큰 자바 응용프로그램에는 개발, 유지보수 등에 적합
4. 현실적으로 모듈로 나누어 자바 프로그램을 작성할 필요 없음
5. 모듈화 작업은 매우 중요한 개념이며, 소규모 프로젝트부터 적용해야 할 대형 프로젝트 쉽게 도입, 활용할 수 있다.

# 3교시
### 패키지 사용하기, import문
* 다른 패키지에 작성된 클래스 사용
1. import를 이용하지 않는 경우 -> 소스에 클래스 이름의 완전 경로명 사용

* 필요한 클래스만 import
1. 소스 시작 부분에 클래스의 경로명 import
2. import 패키지, 클래스
3. 소스에는 클래스 명만 명시하면 됨

* 패키지 전체를 import
1. 소스 시작 부분에 패키지의 경로명.* import
2. import 패키지.*
3. 소스에는 클래스 명만 명시하면 됨
4. import java.util.*; -> java.util 패키지 내의 모든 클래스만을 지정, 하위 패키지의 클래스는 포함하지 않음

### 패키지 만들기
* 클래스 파일(.class)이 저장되는 위치는?
1. 클래스나 인터페이스가 컴파일 되면 클래스 파일(.class) 생성
2. 클래스 파일은 패키지로 선언된 디렉터리에 저장
* 패키지 선언
1. 소스 파일의 맨 앞에 컴파일 후 저장될 패키지 지정 -> package 패키지명;

### 디폴트 패키지
* package 선언문이 없는 자바 소스 파일의 경우
1. 컴파일러는 클래스나 인터페이스를 디폴트 패키지에 소속시킴
2. 디폴트 패키지 -> 현재 티렉터리리

### package의 운영 방법
* 패키지 이름은 도메인 기반으로 시작 (일반 관례)형식 : com.회사이름. 프로젝트명.기능명 -> 충돌 방지(전 세계 어디서든 유일한 패키지명 확보 가능)/ 모듈별 분리 가능

# 최원재 202230137
## 4월 18일(보강)

# 1교시
### Static 메소드 제약 조건 1
* static 메소드는 오직 static 멤버만 접근 가능
1. 객체가 생성되지 않은 상황에서도 static 메소드는 실행될 수 있기 때문에, non-static 멤버 활용 불가
2. non-static 메소드는 static 멤버 사용 가능 

### static 메소드의 제약 조건 2
* static 메소드는 this 사용불가
* static 메소드는 객체 없이도 사용 가능하므로, this 레퍼런스 사용할 수 없음

### final 필드
* final 필드 : 상수를 선언할 때 사용
* 상수는 필드 선언 시에 초기 값을 지정하여야 한다.

### 상속

#### 상속(inheritance)의 필요성
* 상속이 없는 경우 중복된 멤버를 가진 4개의 클래스
* 상속을 이용한 경우 중복이 제거되고 간결해진 클래스 구조

### 클래스 상속과 객체
* 상속 선언 : extends 키워드 사용
* 부모 클래스를 물려받아 자식 클래스를 확장한다는 의미
* 부모 클래스 -> 슈퍼 클래스
* 자식 클래스 -> 서브 클래스
* colorpoint는 point를 물려 받으므로, point에 선언된 필드와 메소드 선언 필요 없음

#### 예제 
* (x, y)의 한 점을 표현하는 point 클래스와 이를 상속받아 점에 색을 추가한 colorpoint 클래스
~~~~java
public class Ex51ColorPoint {
    public static void main(String[] args) {
        Point p = new Point();
        p.set(1, 2);
        p.showPoint();

        ColorPoint cp = new ColorPoint();
        cp.set(3, 4);
        cp.setColor("red");
        cp.showColorPoint();
    }
}

class Point {
    private int x, y;

    public void set(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public void showPoint() {
        System.out.println("(" + x + ", " + y +")");

    }
}


class ColorPoint extends Point {
    private String color;

    public void setColor(String color) {
        this.color = color;
    }

    public void showColorPoint() {
        System.out.print(color);
        showPoint();
    }
}
~~~~

### 서브 클래스 객체의 모양
* 슈퍼 클래스 객체와 서브 클래스의 객체는 별개
* 서브 클래스 객체는 슈퍼 클래스 멤버 포함함

### 자바 상속의 특징 
* 클래스 다중 상속 불허, 하나의 클래스가 둘 이상의 부모 클래스를 동시에 상속받는 것을 말함
1. C++는 다중 상속 가능
2. C++는 다중 상속으로 멤버가 중복 생성되는 문제 있음(다이아몬드 상속)
* 자바는 인터페이스의 다중 상속 허용
* 모든 자바 클래스는 묵시적으로 object 클래스 상속받음
1. java,lang.object는 클래스는 모든 클래스의 슈퍼 클래스

### 슈퍼 클래스의 멤버에 대한 서브 클래스의 접근
* 슈퍼 클래스의 private 멤버 : 서브 클래스에서 접근할 수 없음
* `` 디폴트 멤버 : 서브 클래스가 동일한 패키지에 있을 때, 접근 가능
* `` public 멤버 : 서브 클래스는 항상 접근 가능
* `` protected 멤버 : 같은 패키지 내의 모든 클래스 접근 허용, 패지키 여부와 상관없이 서브 클래스는 접근 가능

### 서브/슈퍼 클래스의 생성자 선택
* 슈퍼/서브 클래스 : 각각 여러 개의 생성자 작성 가능
* 서브 클래스의 객체가 생성될 때 : 슈퍼 클래스 생성자 1개와 서브 클래스 생성자 1개가 실행
* 서브 클래스의 생성자와 슈퍼 클래스의 생성자가 결정되는 방식
1. 개발자의 명시적 선택 1. 서브 클래스 개발자가 슈퍼 클래스의 생성자 명시적 선택 2. super() 키워드를 이용하여 선택
2. 컴파일러가 기본 생성자 선택 1. 서브 클래스 개발자가 슈퍼 클래스의 생성자를 선택하지 않는 경우 2. 컴파일러가 자동으로 슈퍼 클래스의 기본 생성자 선택

### super()로 슈퍼 클래스의 생성자 명시적 선택
* super() : 서브 클래스에서 명시적으로 슈퍼 클래스의 생성자 선택 호출
* 사용 방식
1. super(parameter);
2. 인자를 이용하여 슈퍼 클래스의 적당한 생성자 호출
3. 반드시 서브 클래스 생성자 코드의 제일 첫 라인에 와야 함.
### 예제 super()를 활용한 ColorPoint작성
~~~~java
class Point1 {
    private int x, y;
    public Point1() {
        this.x = this.y = 0;
    }
    public Point1(int x, int y) {
        this.x = x; this.y = y;
    }
    public void showPoint() {
        System.out.println("("+ x + "," + y + ")");

    }
}

class ColorPoint1 extends Point1 {
    private String color;
    public ColorPoint1(int x, int y, String color) {
        super(x, y);
        this.color = color;
    }
    public void showColorPoint() {
        System.out.print(color);
        showPoint();
    }
}
public class Ex52Super {
    public static void main(String[] args) {
        ColorPoint1 cp = new ColorPoint1(5, 6, "blue");
        cp.showColorPoint();
    }
}
~~~~
 ### 업캐스팅 개념
 * 하위 클래스의 레퍼런스는 상위 클래스를 가리킬 수 없지만, 상위 클래스의 레퍼런스는 하위 클래스를 가리킬 수 있다는 설명 (이미지 참조)

 #### 업캐스팅
 * 생물이 들어가는 박스에 사람이나 코끼리를 넣어도 무방 - 모두 생물을 상속받았기 때문.

 * 업캐스팅이란?
 1. 서브 클래스의 레퍼런스를 슈퍼 클래스 레퍼런스에 대입
 2. 슈퍼 클래스 레퍼런스로 서브 클래스 객체를 가리키게 되는 현상

 ### 다운캐스팅 
 * 슈퍼 클래스 레퍼런스를 서브 클래스 레퍼런스에 대입
 * 업캐스팅 된 것을 다시 원래대로 되돌리는 것
 * 반드시 명시적 타입 변환 지점

 ### 업캐스팅 레퍼런스로 객체 구별?
 * 업캐스팅된 레퍼런스로는 객체의 실제 타입을 구분하기 어려움
 * 슈퍼 클래스는 여러 서브 클래스에 상속되기 떄문
 
 ### instanceof 연산자 사용
 * 레퍼런스가 가리키는 객체의 타입 식별 : 연산의 결과는true/false의 불린 값으로 반환
 
 ### 메소드 오버라이딩의 개념
 * 서브 클래스에서 슈퍼 클래스의 메소드 중복 작성
 * 슈퍼 클래스의 메소드 무력화, 항상 서브 클래스에 오버라이딩한 메소드가 실행되도록 보장됨
 * "메소드 무시하기"로 변역되기도 함
 * 오버라이딩 조건 -> 슈퍼 클래스 메소드의 원형(메소드 이름, 인자 타입 및 개수, 리턴 타입) 동일하게 작성

 #### 오버라이딩의 목적, 다형성 실현
 * 오버라이딩으로 다형성 실현
 * 하나의 인터페이스(같은 이름)에 서로 다른 구현
 * 슈퍼 클래스의 메소드를 서브 클래스에서 각각 목적에 맞게 다르게 구현
### 예제
 ~~~~java
class Shape {
    public void draw() {
        System.out.println("Shape");
    }
}

class Line extends Shape {
    public void draw() {
        System.out.println("Line");
    }
}
class Rect extends Shape {
    public void draw() {
        System.out.println("Rect");
    }
}


class Circle extends Shape {
    public void draw() {
        System.out.println("Circle");
    }
}

public class Ex54MethodOverriding {
    static void paint(Shape p) {
        p.draw();
    }

    public static void main(String[] args) {
        Line line = new Line();
        paint(line);

        paint(new Shape());
        paint(new Line());
        paint(new Rect());
        paint(new Circle());
    }
}
 ~~~~

 ###  super 키워드로 슈퍼 클래스의 멤버 접근
 * 슈퍼 클래스의 멤버를 접근할 때 사용되는 레퍼런스 super.슈퍼클래스의 멤버
 * 서브 클래스에서만 사용
 * 슈퍼 클래스의 필드 접근
 * 슈퍼 클래스의 메소드 호출 시 super로 이루어지는 메소드 호출 : 정적 바인딩

# 메일로 보내서 복습할 것
# 최원재 202230137
## 4월 17일(7주차)

# 1교시

### 생성자의 종류
* 기본 생성자 : 매개 변수 없고, 아무 작업 없이 단순 리터나는 생성자

* 기본 생성자가 자동 생성되는 이유
1. 클래스에 생성자가 하나도 선언되어 있지 않을 때 
2. 컴파일러에 의해 기본 생성자 자동 생성
* 기본 셍성자가 자동 생성되지 않는 경우
1. 클래스에 생성자가 선언되어 있는 경우
2. 컴파일러는 기본 생성자를 자동 생성해 주지 않는다.

### this 래퍼런스
1. 객체 자신의 대한 래퍼런스
2. 컴파일러에 의해 자동 관리, 개발자는 사용하기만 하면 돰
3. this.멤버 형태로 멤버를 접근할 때 사용

#### this()로 다른 생성자 호출
1. 같은 클래래스의 다른 생성자 호출
2. 생성자 내에서만 사용 가능
3. 생성자 코드의 제일 옆에 있어야함
this() 사용 실패 사례
this(**,**,0); 

### 객체 배열
* 객체에 대한 레퍼런스 배열

* 자바의 객체 배열 만들기 3단계
1. 배열 레퍼런스 변수 선언
2. 레퍼런스 배열 생성
3. 배열의 각 원소 객체 생성

# 2교시
### 메소드
* 메소드는 C/C++의 함수와 동일
* 자바의 모든 메소드는 반드시 클래스 안에 있어야 함(캡슐화 원칙)
* 접근 지정자 : 다른 클래스에서 메소드를 접근할 수 있는지 여부 선언

### 인자 전달 

#### 기본 타입의 값이 전달되는 경우
* 매개 변수가 byte, int, double 등 기본 타입으로 선언되었을 때 -> 호출자가 건네는 값이 매개 변수에 복사되어 전달. 실 인자 값은 변경되지 않음
#### 객체가 전달되는 경우
* 객체의 레퍼런스만 전달 : 매개 변수가 실 인자 객체 공유
#### 배열이 전달되는 경우
* 배열 레퍼런스만 매개 변수에 전달 : 배열 통째로 전달되지 않음
* 객체가 전달되는 경우와 동일 : 매개 변수가 실인자의 배열 공유

### 메소드 오버로딩
* 한 클래스 내에서 두 개 이상의 이름이 같은 메소드 작성
1. 메소드 이름이 동일해야 함
2. 매게 변수의 개수 혹은 타입이 달라야함
3. 리턴 타입은 오버로딩과 관련 없음

#### 객체 치환 시 주의할 점
* 객체 치환은 객체 복사가 아니며, 레퍼런스의 복사이다.

### 객체 소멸
* new로 할당 받은 객체와 메모리를 JVM으로 되돌려 주는 행위
* 자바는 객체 소멸 연산자 없음
* 객체 소멸은JVM의 고유한 역할

* C/C++에서는 할당 받은 객체를 개발자가 프로그램 내에서 삭제해야 함
* C/C++의 프로그램 작성을 어렵게 만드는 요인
* 자바에서는 사용하지 않는 객체나 배열을 돌려주는 코딩 책임으로부터 개발자 해방

### 가비지
* 가리키는 레퍼런스가 하나도 없는 객체
* 더 이상 접근할 수 없어 사용할 수 없게 된 메모리
* 가비지 컬렉션 : 자바 가상 기계의 가비지 컬렉터가 자동으로 가비지 수집, 반환

### 가비지 컬렉션
* JVM이 가비지 자동 회수
1. 가용 메모리 공간이 일정 이하로 부족해질 때
2. 가비지를 수거하여 가용 메모리 공간으로 확보
* 가비지 컬렉터에 의해 자동 수행


* 강제 가비자 컬렉션 강제 수행 : System. 또는 Runtime 객체의 gc() 메소드 호출
* 이 코드는 JVM에 강력한 가비지 컬렉션 요청
* 그러나 JVM이 가비지 컬렉션 시점을 전적으로 판단

### 자바의 패키지 개념
* 패키지
* 상호 관려 있는 클래스 파일(컴파일된 .class)을 저장하여 관리하는 디렉터리
* 자바 응용프로그램은 하나 이상의 패키지로 구성

### 접근 지정자
* 자바의 접근 지정자 4가지 : private, protected, public, 디폴트(접근 지정자 생략)
* 접근 지정자의 목적
1. 클래스나 일부 멤버를 공개하여 다른 클래스에서 접근하도록 허용
2. 객체 지향 언어의 캡슐화 정책은 멤버를 보호하는 것 -> 접근 지정은 캡슐화에 묶인 보호를 일부 해제할 목적으로 사용
* 접근 지정자에 따른 클래스나 멤버의 공개 범위

### 클래스 접근 지정
* 다른 클래스에서 사용하도록 허용할 지 지정
* public 클래스 : 다른 모든 클래스에게 접근 허용
* 디폴트 클래스(접근 지정자 생략) : 같은 패키지의 클래스에만 접근 허용

### 멤버 접근 지정
* public 멤버 : 패키지에 관계 없이 모든 클래스에게 접근 허용
* private 멤버 : 동일 클래스 내에만 접근 허용. 상속 받은 서브 클래스에서 접근 불가
* protected 멤버 : 
1. 같은 패키지 내의 다른 모든 클래스에게 접근 허용
2. 상속 받은 서브 클래스는 다른 패키지에 있어도 접근 가능
* 디폴트(default) 멤버 : 같은 패키지 내의 다른 클래스에게 접근 허용

### static 멤버
* static 멤버 선언
~~~~java
class StaticSample {
    int n;
    void () {....}

    static int m;
    static void f() {....}
}
~~~~

#### static 멤버의 생성
* static 멤버는 클래스당 하나만 생성
* 객체들에 의해 공유됨
#### static 멤버 사용
* 클래스 이름으로 접근 가능
~~~~java 
staticSample.m = 3; // 클래스 이름으로 static 필드 접근 
staticSample.f(); // 클래스 이름으로 static 메소드 호출
~~~~
* 객체의 멤버로 접근 가능

* non-static 멤버는 클래스 이름으로 접근 안 됨

#### static 활용
* 전역 변수와 전역 함수를 만들 때 활용
* 공유 멤버를 만들 때 : static으로 선언한 멤버는 클래스의 객체들 사이에 공유

#### static 멤버를 가진 Calc 클래스 작성
~~~~java
class Calc {
    public static int abs(int a) {return a>0?a:-a;}
    public static int max(int a, int b) {return (a>b)?a:b;}
    public static int min(int a, int b) {return (a>b)?b:a;}
}

public class Ex411CalcEx {
    public static void main(String[] args) {
        System.out.println(Calc.abs(-5));
        System.out.println(Calc.max(10, 8));
        System.out.println(Calc.min(-3, -8));
    }
}
~~~~



# 최원재 202230137
## 4월 10일(6주차)

# 1교시
~~~~java
Scanner scanner = new Scanner(System.in);
        System.out.println("정수 3개를 입력하세요");
        int sum=0, n=0;
        for(int i=0; i<3; i++){
            System.out.print(i+">>");
            try {
                n = scanner.nextInt();
            }
            catch (InputMismatchException e) {
                System.out.println("정수가 아닙니다. 다시 입력하세요.");
                scanner.next();
                i++;
                continue;
            }
            sum += n;
        }
        System.out.println("헙은" + sum);
        scanner.close();
~~~~

### 자바의 객체지향 특성 : 캡슐화
* 캡슐화: 객체를 캡슐로 싸서 내부를 볼 수 없게 하는 것
1. 객체의 가장 본질적인 특징, 외부의 접근으로부터 객체 보호
* 자바의 캡슐화
1. 클래스(class) : 객체 모양을 선언한 틀(캡슐화하는 틀)
2. 객체: 생성된 실체(instance) : 클래스 내에 메소드와 필드 구현

### 자바의 객체지향 특성 : 상속
* 상속
1. 상위 객체의 속성이 하위 객체에 물려줌
2. 하위 개체가 사위 객체의 속성을 모두 가지는 관계
* 실세계의 상속 사례
1. 나무는 식물의 속성과 생물의 속성을 모두 가짐
2. 사람은 생물의 속성은 가지지만 식물의 속성은 가지고 있지 않음

### 자바의 객체지향 특성 : 다형성
* 다형성 
1. 같은 이름의 메소드가 클래스 혹은 객체에 따라 다르게 구현되는 것
* 다형성 사례
1. 메소드 오버로딩 : 한 클래스 내에서 같은 이름이지만 다르게 작동하는 여러 메소드
2. 메소드 오버라이딩 : 슈퍼 클래스의 메소드를 동일한 이름으로 서브 클래스마다 다르게 구현

### 객체 지향 언어의 목적
* 소프트웨어의 생산성 향상
1. 소프트웨어의 생명 주기 단축
2. 소프트웨어를 빠른 속도로 생산할 필요성 증대

* 객체 지향 언어
1. 상속, 다형성, 객체, 캡슐화 등 소프트웨어 재사용을 위한 여러 장치 내장
2. 소프트웨어 재사용 부분 수정 빠름
3. 소프트웨어를 다시 만드는 부담 대폭 줄임
4. 소프트웨어 생산성 향상

# 2교시

*절차지향 프로그래밍과 객체 지향 프로그래밍
* 절차 지향 프로그래밍
1. 작업 순서를 표현하는 컴퓨터 명령 집합
2. 함수들의 집합으로 프로그램 작성
* 객체 지향 프로그래밍
1. 컴퓨터가 수행하는 작업을 객체들 간의 상호 작용으로 표현
2. 클래스 혹은 객체들의 집합으로 프로그램 작성

### 클래스와 객체
* 클래스 : 객체의 속성과 행위 선언. 객체의 설계도 혹은 틀.
* 객체 : 클래스의 틀로 찍어낸 실체
1. 프로그램 실행 중에 생성되는 실체
2. 메모리 공간을 갖는 구체적인 실체
3. 인스턴스라고도 부름

* 사례
1. 클래스 : 소나타자동차, 객체 : 출고된 실제 소나타 100대
2. 클래스 : 벽시계, 객체 : 우리집 벽에 걸린 벽시계들
3. 클래스 : 책상, 객체 : 우리가 사용중인 실제 책상들게

### 자바 클래스 구성
* 클래스
1. class 키워드로 선언
2. 멤버 : 클래그 구성 요소. 필드(멤버 변수)와 메소드(멤버 함수)
3. 클래스에 대한 public 접근 지정 : 다른 모든 클래스에서 클래스 사용 허락
4. 멤버에 대한 public 접근 지정 : 다른 모든 클래스에게 멤버 접근 허용

# 3교시 

~~~~~~java

    public class Ex41Circle {
        int radius;
        String name;

        public double getArea() {
            return 3.14 * radius * radius;
        }

    public static void main(String[] args) {
        Ex41Circle pizza;
        pizza = new Ex41Circle();
        pizza.radius = 10;
        pizza.name = "자바피자";
        double area = pizza.getArea();
        System.out.println(pizza.name + "의 면적은 " + area);

        Ex41Circle donut = new Ex41Circle();
        donut.radius = 2;
        donut.name = "자바도넛";
        area = donut.getArea();
        System.out.println(donut.name + "의 면적은 " + area);
        }  
    }

~~~~~~

### 생성자 개념과 목적
1. 객체가 생성될 때 초기화 목적으로 실행되는 메소드
2. 객체가 생성되는 순간에 자동 호출 

* 생성자의 특징
1. 생성자 이름은 클래스 이름과 동일
2. 생성자는 여러 개 작성 가능(생성자 중복)
3. 생성자는 객체 생성시 한 번만 호출
4. 생성자의 목적은 객체 생성 시 초기화
5. 생성자는 리턴 타입을 지정할 수 없음






# 최원재 202230137
## 4월 3일(5주차)

# 1교시

### 반복문
1. 자바 반복문 - for문, while문, do-while문

* while : 조건식이 '참'인 동안 반복 실행
* do-while : 조건식이 '참'인 동안 반복 실행
* 중첩반복 : 반복문이 다른 반복문을 내포하는 구조
* continue : 반복문을 빠져 나가지 않고, 다음 반복으로 제어 변경
* break : 반복문 하나를 즉시 벗어날 때 사용. 하나의 반복문만 벗어남. 중첩 반복의 경우 안쪽 반복문의 break 문이 실행되면 안쪽 반복문만 벗어남.

# 2교시
### 자바 배열(array)
1. 인덱스와 인덱스로 대응하는 데이터들로 이루어진 자료 구조. 한 번에 많은 메모리 공간 선언.
2. 같은 타입의 데이터들이 순차적으로 저장되는 공간으로 인덱스를 이용하여 원소 데이터 접근.
3. 반복문을 이용하여 처리하기에 적합한 자료 구조

### 배열 선언 및 생성 디테일
1. 배열은 선언과 생성의 두 단계 필요 : 선언과 동시에 생성할 수 있음.
2. 배열 선언 : 배열의 이름 선언 (int intArray[]; 또는 int[] intArray;)
3. 배열 생성 : 배열 공간 할당 받는 과정
4. 배열의 인덱스는 0부터, 크기 1부터.
5. 인덱스를 잘못 사용한 경우 (int n = intArray[-2]; <-음수 사용 불가 int n = intArray[5] <- 인덱스의 범위는 (0~4))

# 3교시
## 배열
### 배열의 크기, length 필드
1. 자바의 배열은 객체로 처리
2. 배열의 크기는 배열 객체의 length 필드에 저장

### 배열과 for-each 문
1. for=each 문 : 배열이나 나열의 원소를 순차 접근하는데 유용한 for문
### 메소드의 배열 리턴
1. 배열의 레퍼런스만 리턴되며, 배열 전체가 리턴되는 것이 아님
2. 메소드이 리턴 타입 : 리턴하는 배열타입과 리턴 받는 배열 타입 일치, 리턴 타입에 배열의 크기를 지정하지 않음

### 자바의 예외 처리, try-catch-finally문
1. 예외처리 : 발생한 예외에 대해 개발자가 작성한 프로그램 코드에서 대응하는 것
2. try-catch-finally문, finally 블록은 생략 가능





# 최원재 202230137
## 3월 27일(4주차)

# 1교시

### 자바의 특징
1. 메모리 할당 기능O
2. 메모리 반환 기능X
3. 사용하지 않는 메모리는  JVM에 의해 자동 반환 - 가비지 컬렉션
4. 실시간 응용프로그램 부적합 자바 프로그램은 안전
6. 프로그램 작성 쉬움
7. 실행속도 개선을 위한 JIT 컴파일러 사용 
### 소스코드, 바이트 코드, 기계어
1. 소스코드 : 우리가 작성하는 Java 코드 (사람이 읽을 수 있는 고수준 언어)
2. 바이트 코드 : Java 컴파일러가 소스코드를 변환한 중간 코드 (CPU가 직접 실행X)
3. 기계어 : CPU가 직접 실행할 수 있는 0과 1의 이진 코드(16진수 형태의 기계어)
* 바이트코드와 기계어 차이 : 
1. 바이트코드 - JVM이 실행하는 중간 코드 - 운영체제와 CPU에 관계없이 사용 O 
2. 기계어 - CPU가 직접 실행하는 코드 - 특정 하드웨어에 종속
### 식별자
식별자 : 클래스, 변수, 상수, 메소드 등에 붙이는 이름
* 식별자 원칙
1. 특수문자, 공백, 탭X (_ $)는 가능
2. 한글 사용X 유니코드 문자 O
3. 첫번쨰 문자 숫자X
4. 길이제한 X
5. 대소문자 구별
6. 자바 언어의 키워드는 식별자로 사용불가(Ex for, if)
7. true, false, null 사용X
### Java의 데이터타입
* 기본자료형 8개 : boolean, char, byte, short, int, long, float, double
* 레퍼런스형 3개 : 클래스(class), 인터페이스(InterFace), 배열(Array)
### 참조 자료형(Reference Type)
1. 포인터는 임의의 메모리 주소를 저장 하는 반면, 참조 자료형은 주소를 저장할 수 없음
2. 객체를 참조하는 변수 유형 
3. 객체를 참조하지 않을 때 null값을 가질 수 있음
4. 배열, 인터페이스, 열거형도 객체 - 참조 자료형이다.
#### Java는 왜 참조 자료형을 사용할까
1. 메모리 안전성
2. 가비지 컬렉션 지원
3. 코드의 단순화 및 가독성 향상
4. 보안 강화(Security) - 보안이 중요한 웹 서버, 금융 시스템, 웹 개발 등에서 사용되는 이유
5. 다중 플랫폼 지원(Portable)
### 메모리의 구조
1. 힙(heap - FIFO) 영역 :  프로그래머가 직접 공간을 할당, 해제하는 메모리 공간
2. 스택(stack - LIFO) 영역 :  프로그램이 자동으로 사용하는 임시 메모리 영역
3. 힙이 스택을 침범하는 경우 - 힙 오버 플로우
4. 스택이 힙을 침번하는 경우 - 스택 오버 플로우
# 2교시
### 변수, 상수 선언
* 변수
1. 변수 : 값을 임시로 저장
2. 변수 선언 :데이터 타입에서 정한 크기의 멤리 할당
* 상수
1. final 키워드 사용
2. 선언할 떄 초기값 지정, 실행 중 값의 변경은 불가능

### var 키워드
1. 타입을 생략, 변수 선언 가능
2. 컴파일러가 추론, 변수 타입 결정
3. 변순 선언 초기값X -> 컴파일 오류 발생 (Ex var foo = 1.4; - 이렇게 초기값을 줘야함)
4. 지역 변수 : 메소드 내부 선언
5. 클래스 : 클래스 내부 선언

### System.out.print의 종류
1. System.out.print() 줄바꿈x
2. System.out.println() 줄바꿈o
3. System.out.printf() 형식 지정 문자열을 출력할 때

### 타입 변환
다른 데이터 타입의 값으로 변환.
1. 자동 타입 변환 : 타입이 일치하지 않을 때 (Ex duble d = 3.14*10; //실수 연산 위해 10이 10.0으로 자동 변환)
2. 강제 타입 변환 : 개발자의 의도적 변환

### 자바의 키 입력 System.in vs. Scanner
* System.in
1. 표준 입력 스트림
2. 바이트(문자 아님)로 리턴하는 저수준 스트림
3. 바이트를 문자나 숫자로 변환하는 많은 어려움 있음
* Scanner
1. 바이트를 문자, 정수, 실수, 불린 문자열 등 다양한 타입으로 변환하여 리턴
2. 객체를 생성해서 사용
3. System.in에게 키를 읽게 하고 원하는 타입으로 변환하여 리턴
4. 공백으로 구분, 토큰 단위로 읽음 (공백문자 : \t, \r, \n , '', 등)

# 3교시
### 연산
#### 증감
1. 1 증가 혹은 감소 시키는 연산 : +, -
#### 대입 연산
1. 연산의 오른쪽 결과는 왼쪽 변수에 대입
#### 비교 연산, 논리 연산
1. 비교연산자 : 두 개의 값을 비교하여 true
2. 논리연산자 : 두 개의 논리 값에 논리 연산, 논리 결과
#### 조건 연산
1. 3 개의 피연산자로 구성된 삼항 연산자
#### 비트 연산
1. 비트 논리 연산 : 비트끼리 AND, OR, XOR, NOT 연산
2. 비트 시프트 연산 : 비트를 오른쪽이나 왼쪽으로 이동
3. 데이터 압축 및 최적화, 해싱 및 암호화, 빠른 연산









# 최원재 202230137
## 3월 20일(3주차)
# 2교시

프로그래밍 언어의 진화
고급언어, 어셈블리어언어, 객체지향언어 쓰임새

* 프로그래밍과 컴파일<br>
자바 -> .java -> .class
c -> .obj -> .exe

* 자바의 태동<br> 
가전제품에 들어갈 소프트웨어를 위해 개발
목적 : 플랫폼 호환성 문제 해결, 플랫폼 독립적인 언어 개발, 메모리사용량이 적고 여러제품에 적용

* 자바 JVM과 자바 실행 환경<br>
바이트 코드(.class)
자바 jvm에서 실행가능한 바이너리 코드
jVM(Java Virtual Machine)
각기 다른 플랫폼에 맞는 JVM제공

# 3교시
* 자바 응용프로그램 실행 환경<br>
JVM + Java API

* Java의 네이밍 방식<br>
내부 버전 표기 1.x.x 형태로 유지중

모듈 : 자바패키지들과 이미지 XML파일 등의 자원들을 묶은 단위

* 자바의 특징<br>
-실행 코드 배포 : 한 개의 class파일 또는 다수의 class 파일로 구성<br>
-패키지 : 서로 관련 있는 여러 클래스를 패키지로 묶어 관리<br>
-멀티스레드 : 여러 스레드의 동시 수행 환경 지원 <br>
자바는 운영체제의 도움없이 자체적으로 멀티스레드 지원





### README 파일 편집

# 최원재 202230137
## 3월 13일(2주차)
소스 컨트롤을 왜 사용하고 이용해야 하는지 그리고 여러 기본 태그들을 배움

### README 파일 편집 

# h1 tag
## h2
### h3
#### h4
##### h5
###### h6

---

* 가가가
- 나나나

1. 나나나
2. 가가가
7. 다다다

```java
import java.util.Scanner;

public class HelloWorld {

    public static void main(String[] args) {

        // Creates a reader instance which takes
        // input from standard input - keyboard
        Scanner reader = new Scanner(System.in);
        System.out.print("Enter a number: ");

        // nextInt() reads the next integer from the keyboard
        int number = reader.nextInt();

        // println() prints the following line to the output screen
        System.out.println("You entered: " + number);
    }
}
```
